name: "Build, Push and Deploy a container image to Kubernetes"
# Requires `csproj` file contains `<EnableSdkContainerSupport>true</EnableSdkContainerSupport>` tag and a deployment folder to be present in the repository.

on:
  workflow_call:
    secrets:
      TRAKX_GITHUB_TOKEN:
        description: "Access token provided by the calling action context, used to publish the packages and push the corresponding tag."
        required: false
      TRAKX_BOT_READONLY_PAT:
        description: "Personal access token used to access the github private nuget source."
        required: true
    inputs:
      projectFolder:
        description: "Folder containing the project to build."
        required: true
        type: string
      serviceName:
        description: "Name of service being deployed."
        required: true
        type: string
      imageName:
        description: "Name of the docker image to build. If not provided, will be the same as 'serviceName'."
        required: false
        type: string
      runnerName:
        description: "Name of the runner to use. If not provided, will be generated based on the branch name."
        required: false
        type: string
        default: ''
      environment:
        description: "Environment to deploy to (dev | staging | production). If not provided, will be generated based on the branch name."
        required: false
        type: string
        default: ''
      containerPublishType:
        description: "Type of container publish (api | worker). Default is api."
        required: false
        type: string
        default: 'api'
      imageTagPrefix:
        description: "Prefix of the docker image tag. If not provided, will be generated based on the environment."
        required: false
        type: string
        default: ''
      dotnetVersion:
        description: "Version of dotnet to use. Default is v7.x."
        required: false
        type: string
        default: "7.x"
      dockerRegistry:
        description: "Docker registry to push the image to. Default is docker.pkg.github.com."
        required: false
        type: string
        default: "docker.pkg.github.com"
      actionsRepoRef:
        description: "Run actions from this ref. Default is master."
        type: string
        required: false
        default: "master"

env:
  IMAGE_NAME: ${{ inputs.imageName || inputs.serviceName }}
  GITHUB_TOKEN: ${{ secrets.TRAKX_GITHUB_TOKEN || secrets.GITHUB_TOKEN }}

jobs:
  pick-runner:
    name: "Pick the runner to use"
    runs-on: ubuntu-latest
    outputs:
      runnerName: ${{ steps.pick-runner-step.outputs.runnerName }}
    steps:
      - name: Set variable RUNNER_NAME based on branch name
        id: pick-runner-step
        shell: bash
        run: |
          RUNNER_NAME="${{ inputs.runnerName }}"

          if [[ -z "$RUNNER_NAME" ]]; then
            if [[ "${{ github.ref }}" == "refs/heads/prod" || "${{ github.ref }}" == "refs/heads/master" ]]; then
                RUNNER_NAME="prod-trakx-runner"
            elif [[ "${{ github.ref }}" == "refs/heads/stage" ]]; then
                RUNNER_NAME="stage-trakx-runner"
            else
                RUNNER_NAME="dev-trakx-runner"
            fi
          fi
          echo "Using runner: $RUNNER_NAME"
          echo "RUNNER_NAME=$RUNNER_NAME" >> $GITHUB_ENV
          echo "runnerName=$RUNNER_NAME" >> $GITHUB_OUTPUT

  pick-environment:
    name: "Pick the environment to deploy"
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.pick-environment-step.outputs.environment }}
    steps:
      - name: Set variable DEPLOYMENT_ENVIRONMENT based on branch name
        id: pick-environment-step
        shell: bash
        run: |
          DEPLOYMENT_ENVIRONMENT="${{ inputs.environment }}"
          if [[ -z "$DEPLOYMENT_ENVIRONMENT" ]]; then
            if [[ "${{ github.ref }}" == "refs/heads/prod" || "${{ github.ref }}" == "refs/heads/master" ]]; then
                DEPLOYMENT_ENVIRONMENT="production"
            elif [[ "${{ github.ref }}" == "refs/heads/stage" ]]; then
                DEPLOYMENT_ENVIRONMENT="staging"
            else
                DEPLOYMENT_ENVIRONMENT="development"
            fi
          fi
          echo "Deploying to environment: $DEPLOYMENT_ENVIRONMENT"
          echo "DEPLOYMENT_ENVIRONMENT=$DEPLOYMENT_ENVIRONMENT" >> $GITHUB_ENV
          echo "environment=$DEPLOYMENT_ENVIRONMENT" >> $GITHUB_OUTPUT

  validate-event:
    name: "Validate if event is allowed for the given environment"
    needs: [ pick-environment ]
    runs-on: ubuntu-latest
    steps:
      - name: Block workflow_dispatch for staging and production
        shell: bash
        run: |
          if [[ "${{ needs.pick-environment.outputs.environment }}" == "production" || "${{ needs.pick-environment.outputs.environment }}" == "staging" ]]; then
            if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
              echo "Event workflow_dispatch is not allowed for environment ${{ needs.pick-environment.outputs.environment }}."
              exit 1
            fi
          fi

  build-push-container:
    name: "Build and push container image"
    needs: [ pick-runner, pick-environment, validate-event ]
    runs-on: ${{ needs.pick-runner.outputs.runnerName }}
    steps:
      - name: Checkout calling repo
        uses: actions/checkout@v3

      - name: Checkout trakx/github-actions repo
        uses: actions/checkout@v3
        with:
          repository: trakx/github-actions
          path: ./github-actions
          ref: ${{ inputs.actionsRepoRef }}

      - name: Get last commit of calling repo
        id: last-commit-sha
        uses: ./github-actions/get-last-commit

      - name: Set variable CONTAINER_IMAGE_TAG_PREFIX
        shell: bash
        run: |
          IMAGE_TAG="${{ inputs.imageTagPrefix }}"
          if [[ -z "$IMAGE_TAG" ]]; then
            if [[ "${{ needs.pick-environment.outputs.environment }}" == "production" ]]; then
                IMAGE_TAG="prod"
            elif [[ "${{ needs.pick-environment.outputs.environment }}" == "staging" ]]; then
                IMAGE_TAG="stage"
            else
                IMAGE_TAG="dev"
            fi
          fi
          echo "Tagging image prefix with: $IMAGE_TAG"
          echo "CONTAINER_IMAGE_TAG_PREFIX=$IMAGE_TAG" >> $GITHUB_ENV

      - name: Build and push container image
        id: build-push-container-step
        uses: ./github-actions/build-push-container
        with:
          githubToken: ${{ env.GITHUB_TOKEN }}
          packageReadonlyPat: ${{ secrets.TRAKX_BOT_READONLY_PAT }}
          projectFolder: ${{ inputs.projectFolder }}
          imageName: ${{ env.IMAGE_NAME }}
          imageTagPrefix: ${{ env.CONTAINER_IMAGE_TAG_PREFIX }}
          containerPublishType: ${{ inputs.containerPublishType }}
          dotnetVersion: ${{ inputs.dotnetVersion }}
          dockerRegistry: ${{ inputs.dockerRegistry }}
          imageTagSuffix: ${{ steps.last-commit-sha.outputs.lastCommitSha }}
          doCheckout: false
    outputs:
      tag: ${{ steps.build-push-container-step.outputs.tag }}

  deploy-kubernetes:
    name: "Deploy container image to Kubernetes"
    needs: [ pick-runner, pick-environment, build-push-container ]
    runs-on: ${{ needs.pick-runner.outputs.runnerName }}
    if: |
      always() &&
        (needs.build-push-container.result == 'success' || (needs.build-push-container.result == 'skipped'
            && github.event_name == 'workflow_run'
            && github.event.workflow_run.conclusion == 'success' ))
    steps:
      - name: Checkout calling repo
        uses: actions/checkout@v3

      - name: Checkout trakx/github-actions repo
        uses: actions/checkout@v3
        with:
          repository: trakx/github-actions
          path: ./github-actions
          ref: ${{ inputs.actionsRepoRef }}

      - name: Deploy container image to Kubernetes
        id: deploy-container-k8s
        uses: ./github-actions/deploy
        with:
          githubToken: ${{ env.GITHUB_TOKEN }}
          environment: ${{ needs.pick-environment.outputs.environment }}
          tag: ${{ needs.build-push-container.outputs.tag }}
          service: ${{ inputs.serviceName }}
          artifact-name: ${{ env.IMAGE_NAME }}
          serviceRegistry: ${{ inputs.dockerRegistry }}
          type: "kubernetes"
